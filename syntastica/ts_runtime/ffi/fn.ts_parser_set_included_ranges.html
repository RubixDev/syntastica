<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Set the ranges of text that the parser should include when parsing."><title>ts_parser_set_included_ranges in syntastica::ts_runtime::ffi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="syntastica" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0-nightly (30f168ef8 2025-03-05)" data-channel="nightly" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../../static.files/storage-d8ac8691.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-a7bf3405.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../syntastica/index.html">syntastica</a><span class="version">0.5.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In syntastica::<wbr>ts_<wbr>runtime::<wbr>ffi</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">syntastica</a>::<wbr><a href="../index.html">ts_runtime</a>::<wbr><a href="index.html">ffi</a></div><h1>Function <span class="fn">ts_parser_set_included_ranges</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn ts_parser_set_included_ranges(
    self_: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="struct" href="struct.TSParser.html" title="struct syntastica::ts_runtime::ffi::TSParser">TSParser</a>,
    ranges: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="struct" href="struct.TSRange.html" title="struct syntastica::ts_runtime::ffi::TSRange">TSRange</a>,
    count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Set the ranges of text that the parser should include when parsing.</p>
<p>By default, the parser will always include entire documents. This function
allows you to parse only a <em>portion</em> of a document but still return a syntax
tree whose ranges match up with the document as a whole. You can also pass
multiple disjoint ranges.</p>
<p>The second and third parameters specify the location and length of an array
of ranges. The parser does <em>not</em> take ownership of these ranges; it copies
the data, so it doesnâ€™t matter how these ranges are allocated.</p>
<p>If <code>count</code> is zero, then the entire document will be parsed. Otherwise,
the given ranges must be ordered from earliest to latest in the document,
and they must not overlap. That is, the following must hold for all:</p>
<p><code>i &lt; count - 1</code>: <code>ranges[i].end_byte &lt;= ranges[i + 1].start_byte</code></p>
<p>If this requirement is not satisfied, the operation will fail, the ranges
will not be assigned, and this function will return <code>false</code>. On success,
this function returns <code>true</code></p>
</div></details></section></div></main></body></html>