use std::fs;

use anyhow::{anyhow, Error, Result};
use fancy_regex::Regex;
use once_cell::sync::Lazy;

const HEADER: &str = r##"
/////////////////////////////////////////////
//// All following code is autogenerated ////
//// by running `cargo xtask codegen` in ////
//// the syntastica workspace. //////////////
/////////////////////////////////////////////
"##;

static FUNC_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"pub fn ([a-z_]+)\(\) -> ResolvedTheme").unwrap());

pub fn write() -> Result<()> {
    let all_themes = find_all_themes()?;

    let lib_rs_path = crate::WORKSPACE_DIR.join("syntastica-themes/src/lib.rs");
    let mut lib_rs = fs::read_to_string(&lib_rs_path)?;

    if let Some((preserve, _)) = lib_rs.split_once(HEADER) {
        lib_rs.truncate(preserve.len());
    }
    lib_rs += HEADER;

    lib_rs += r###"
/// Try to get a theme given its path as a string.
///
/// For a list of all acceptable theme names see [`THEMES`].
///
/// # Example
///
/// ```
/// assert_eq!(
///     syntastica_themes::from_str("one::dark"),
///     Some(syntastica_themes::one::dark()),
/// );
/// ```
pub fn from_str(theme_name: impl AsRef<str>) -> Option<ResolvedTheme> {
    match theme_name.as_ref() {
"###;
    for theme in &all_themes {
        lib_rs += &format!("        \"{theme}\" => Some({theme}()),\n");
    }
    lib_rs += &r###"
        _ => None,
    }
}

/// A list of all theme names as they are accepted by [`from_str`].
pub const THEMES: &[&str] = &[
"###[1..];
    for theme in &all_themes {
        lib_rs += &format!("    \"{theme}\",\n");
    }
    lib_rs += "];\n";

    fs::write(&lib_rs_path, lib_rs)?;

    Ok(())
}

pub fn find_all_themes() -> Result<Vec<String>> {
    let mut all_themes = crate::WORKSPACE_DIR
        .join("syntastica-themes/src")
        .read_dir()?
        .filter_map(|entry| -> Option<Result<Result<Vec<_>, _>>> {
            let entry = match entry {
                Ok(e) => e,
                Err(err) => return Some(Err(Error::from(err))),
            };

            // skip the `lib.rs` file and directories
            if entry.file_name() == "lib.rs" || entry.path().is_dir() {
                None
            } else {
                let module_name = match entry.file_name().into_string() {
                    Ok(filename) => filename.strip_suffix(".rs")?.to_owned(),
                    Err(_) => return Some(Err(anyhow!("invalid filename encountered"))),
                };

                let contents = fs::read_to_string(entry.path()).ok()?;
                Some(Ok(FUNC_REGEX
                    .captures_iter(&contents)
                    .map(|c| c.map(|captures| format!("{module_name}::{}", &captures[1])))
                    .collect()))
            }
        })
        .collect::<Result<Result<Vec<_>, _>>>()??
        .into_iter()
        .flatten()
        .collect::<Vec<_>>();
    all_themes.sort_unstable();
    Ok(all_themes)
}
